import fs from 'fs-extra';
import path from 'path';

/**
 * Find a README.md file in the given directory
 * @param dir Directory to search in
 * @returns Path to the README.md file, or null if not found
 */
export const findReadmeFile = async (dir: string): Promise<string | null> => {
  const files = await fs.readdir(dir);
  const readmeFile = files.find((file: string) => file.toLowerCase() === 'readme.md');
  return readmeFile ? path.join(dir, readmeFile) : null;
};

/**
 * Read a Markdown file
 * @param filePath Path to the Markdown file
 * @returns Content of the file
 */
export const readMarkdownFile = async (filePath: string): Promise<string> => {
  return fs.readFile(filePath, 'utf8');
};

/**
 * Write content to a Markdown file
 * @param filePath Path to the Markdown file
 * @param content Content to write
 */
export const writeMarkdownFile = async (filePath: string, content: string): Promise<void> => {
  return fs.writeFile(filePath, content, 'utf8');
};

/**
 * Create a default README.md file
 * @param dir Directory to create the file in
 * @returns Path to the created file
 */
export const createReadmeFile = async (dir: string): Promise<string> => {
  const filePath = path.join(dir, 'README.md');
  const content = `# Project README

<!-- Generated by qmims -->

<!-- qmims: Please analyze this project and generate a comprehensive README.md file. Include sections for project overview, installation, usage, and any other relevant information based on the project structure and code. -->
`;
  await writeMarkdownFile(filePath, content);
  return filePath;
};

/**
 * Interface for parsed instruction
 */
export interface Instruction {
  instruction: string;
  lineNumber: number;
  targetStart?: number;
  targetEnd?: number;
}

/**
 * Parse embedded instructions from Markdown content
 * @param content Markdown content
 * @returns Array of instructions with line numbers
 */
export const parseInstructions = (content: string): Instruction[] => {
  if (!content) {
    return [];
  }
  
  const lines = content.split('\n');
  const instructions: Instruction[] = [];
  const instructionRegex = /<!--\s*qmims:\s*(.*?)\s*-->/;

  lines.forEach((line, index) => {
    const match = line.match(instructionRegex);
    if (match && match[1]) {
      const instruction: Instruction = {
        instruction: match[1],
        lineNumber: index + 1, // Line numbers are 1-based
      };
      
      // Look for target markers
      let targetStart = -1;
      let targetEnd = -1;
      
      for (let i = index + 1; i < lines.length; i++) {
        if (lines[i].includes('<!-- qmims-target-start -->')) {
          targetStart = i + 1;
        } else if (lines[i].includes('<!-- qmims-target-end -->')) {
          targetEnd = i;
          break;
        }
      }
      
      if (targetStart !== -1 && targetEnd !== -1) {
        instruction.targetStart = targetStart;
        instruction.targetEnd = targetEnd;
      }
      
      instructions.push(instruction);
    }
  });

  return instructions;
};

/**
 * Extract content between target markers
 * @param content Markdown content
 * @param instruction Optional instruction with target markers
 * @returns Extracted content string or null if no content found
 */
export const extractTargetContent = (content: string, instruction?: Instruction): string | null => {
  if (!content) {
    return null;
  }
  
  const lines = content.split('\n');
  
  // If instruction with target markers is provided, use those
  if (instruction && instruction.targetStart !== undefined && instruction.targetEnd !== undefined) {
    if (instruction.targetStart >= 0 && instruction.targetEnd > instruction.targetStart && instruction.targetEnd < lines.length) {
      return lines.slice(instruction.targetStart, instruction.targetEnd).join('\n');
    }
  }
  
  // Otherwise, look for target markers in the content
  let startIndex = -1;
  let endIndex = -1;

  for (let i = 0; i < lines.length; i++) {
    if (lines[i].includes('<!-- qmims-target-start -->')) {
      startIndex = i;
    } else if (lines[i].includes('<!-- qmims-target-end -->')) {
      endIndex = i;
      break;
    }
  }

  if (startIndex !== -1 && endIndex !== -1 && startIndex < endIndex) {
    return lines.slice(startIndex + 1, endIndex).join('\n');
  }
  
  // If instruction is provided but no target markers, extract the paragraph after the instruction
  if (instruction && instruction.lineNumber !== undefined) {
    const lineNumber = instruction.lineNumber;
    let paragraphStart = -1;
    let paragraphEnd = -1;
    
    // Find the next non-empty line after the instruction
    for (let i = lineNumber; i < lines.length; i++) {
      if (lines[i].trim() !== '' && !lines[i].includes('<!-- qmims')) {
        paragraphStart = i;
        break;
      }
    }
    
    // Find the end of the paragraph (next empty line)
    if (paragraphStart !== -1) {
      for (let i = paragraphStart + 1; i < lines.length; i++) {
        if (lines[i].trim() === '') {
          paragraphEnd = i;
          break;
        }
      }
      
      // If no empty line found, use the end of the file
      if (paragraphEnd === -1) {
        paragraphEnd = lines.length;
      }
      
      return lines.slice(paragraphStart, paragraphEnd).join('\n');
    }
  }

  return null;
};